#!/usr/bin/env python2
# coding=utf-8

"""
Entry-point script for gitver
"""

import sys
import argparse
from os.path import dirname, abspath, realpath, exists, join


def setup_env():
    """Provides access to the gitver modules"""
    prefix = dirname(dirname(realpath(abspath(__file__))))
    gitver_mod = join(prefix, 'gitver', '__init__.py')
    if exists(gitver_mod):
        # source tree
        sys.path.insert(1, prefix)

setup_env()


def main():
    from gitver.termcolors import term

    # check for the git command
    from gitver.git import git_version
    v = git_version()
    if not 'git version' in v:
        term.err("This program requires \"git\" to be installed and "
                 "configured.")
        sys.exit(1)

    # requires the git command
    from gitver.sanity import check_config_dir, check_gitignore, \
        check_project_root

    from gitver.commands import cmd_clean, cmd_cleanall, cmd_next, cmd_version

    # always permit the "version" command to run
    if len(sys.argv) == 2 and sys.argv[1] == 'version':
        cmd_version(None, None)
        sys.exit(0)

    check_project_root()
    inject_default_action()
    parser = create_parser()
    args = parser.parse_args()

    # apply quiet flags
    term.set_quiet_flags(args.quiet_stdout, args.quiet_stderr)

    cfg = None

    # avoid check if 'init' command
    if not 'init' in sys.argv:
        check_config_dir()

        # apply colors configuration
        from gitver.config import load_user_config
        cfg = load_user_config()

        term.enable_colors(cfg['use_terminal_colors'])

        # apply colors from command line
        if args.use_colors == 'yes':
            term.enable_colors(True)
        elif args.use_colors == 'no':
            term.enable_colors(False)

        if cfg['safe_mode'] and not args.ignore_gitignore:
            if args.func in [cmd_next, cmd_clean, cmd_cleanall]:
                if not check_gitignore():
                    term.warn("A potentially unsafe operation has been "
                              "prevented to\ncontinue because your .gitignore "
                              "file doesn't exclude gitver's\nconfiguration "
                              "directory from the repository.\nIf you know what"
                              " you are doing, use the \"--ignore-gitignore\"\n"
                              "flag to ignore this warning or just disable "
                              "\"safe_mode\" in\nyour configuration file.")
                    sys.exit(1)

    return args.func(cfg, args)


def inject_default_action():
    is_short = len(sys.argv) < 2
    only_flags = True
    for arg in sys.argv[1:]:
        only_flags = only_flags and arg.startswith('--')
    if is_short or only_flags:
        sys.argv.append('info')


def create_parser():
    parser = argparse.ArgumentParser()

    # ignore gitver-generated warnings (not recommended!)
    parser.add_argument('--ignore-gitignore',
                        help='Ignore the .gitignore warning and continue '
                             'running as normal (specify this flag before '
                             'any other command, at YOUR own risk)',
                        dest='ignore_gitignore',
                        default=False,
                        action='store_true')

    parser.add_argument('--colors',
                        help='Enable or disable colorized terminal output: '
                             '\'config\' (default) reads the setting from '
                             'your configuration file, \'yes\' will '
                             'force-enable it, \'no\' will force-disable it.',
                        dest='use_colors',
                        type=str,
                        choices=['config', 'yes', 'no'],
                        default='config')

    parser.add_argument('--quiet',
                        help='Disable any stdout message.',
                        dest='quiet_stdout',
                        default=False,
                        action='store_true')

    parser.add_argument('--quiet-errors',
                        help='Disable any stderr message.',
                        dest='quiet_stderr',
                        default=False,
                        action='store_true')

    sp = parser.add_subparsers(title='Valid commands')
    create_commands(sp)
    return parser


def create_commands(sp):
    from gitver.commands import cmd_build_template, cmd_clean, cmd_cleanall, \
        cmd_info, cmd_init, cmd_list_next, cmd_list_templates, cmd_next, \
        cmd_version, cmd_current, cmd_check_gitignore, cmd_preview_template

    add_command(sp, 'version', "Show gitver version", cmd_version)
    add_command(sp, 'init', "Create gitver's configuration directory and "
                            "create the default configuration file, if it "
                            "doesn't exist.", cmd_init)
    add_command(sp, 'check', "Check your .gitignore file for gitver's "
                             "configuration directory inclusion.",
                cmd_check_gitignore)

    add_command(sp, 'info', "Print full version information and tag-based "
                            "metadata for this repository. [default]",
                cmd_info)
    add_command(sp, 'current', "Print the current version information only, "
                               "without any formatting applied.", cmd_current)

    add_command(sp, 'list-templates', "Enumerates available templates.",
                cmd_list_templates)

    add_command(sp, 'list-next', "Enumerates NEXT custom strings.",
                cmd_list_next)

    p = add_command(sp, 'update', "Perform simple keyword substitution on the "
                                  "specified template file(s) and place it to "
                                  "the path described by the first line in the "
                                  "template. This is usually performed "
                                  "*AFTER* a release has been tagged already.",
                    cmd_build_template)
    p.add_argument('templates', default='', type=str)

    p = add_command(sp, 'preview', "Same as \"update\", but the output is "
                                   "written to the stdout instead (same rules "
                                   "apply).",
                    cmd_preview_template)
    p.add_argument('templates', default='', type=str)

    p = add_command(sp, 'next', "Sets the NEXT version numbers for the "
                                "currently reachable last tag.", cmd_next)
    p.add_argument('next_version_numbers', default='', type=str)

    p = add_command(sp, 'clean', "Resets the NEXT custom string for the "
                                 "currently active tag, or the specified tag, "
                                 "to a clean state.", cmd_clean)
    p.add_argument('tag', nargs='?', type=str, default='')

    add_command(sp, 'cleanall', "Resets all the NEXT custom strings for this "
                                "repository.", cmd_cleanall)


def add_command(parent, name, desc, func):
    p = parent.add_parser(name, help=desc)
    p.set_defaults(func=func)
    return p


if __name__ == "__main__":
    sys.exit(main())
