#!/usr/bin/env python2

import os
import re
import sys
import argparse
import pickle
from string import Template
from os.path import dirname, realpath, abspath, basename
from git import get_repo_info

this_script = basename(__file__)


def setup_env():
    # append the path where the real binary resides to the actual sys.path
    sys.path.append(dirname(realpath(__file__)))
setup_env()

cfgdir = ".gitver/"
gitdir = ".git/"
tpldir = os.path.join(cfgdir, 'templates')

# file where to store NEXT user-defined version strings for the specified
# TAG key
next_store_file = os.path.join(cfgdir, ".next_store")

next_suffix = "NEXT"
next_custom_suffix = "SNAPSHOT"
custom_version_matcher = r"v{0,1}(\d+)\.(\d+)\.(\d+)$"


def check_gitdir():
    # check this is a git repo
    if not os.path.exists(gitdir):
        print "Please run this tool from within the root directory of your " \
              "project, where the .git directory resides."
        sys.exit(1)


def check_cfgdir():
    # check config directory exists
    if not os.path.exists(cfgdir):
        print "Please run \"" + this_script + " --init\" first."
        sys.exit(1)


def build_version_string(repo, next_custom=''):
    in_next = repo['count'] > 0
    if in_next and not next_custom is None and len(next_custom) > 0:
        version = next_custom
        if len(next_custom_suffix) > 0:
            version += "-" + next_custom_suffix
    else:
        version = "%d.%d.%d" % (repo['maj'], repo['min'], repo['patch'])
        if in_next:
            version += "-" + next_suffix

    if in_next:
        version += "-" + str(repo['count'])

    version += "/" + repo['build-id']

    return version


def template_path(name):
    return os.path.join(tpldir, name)


def parse_templates(templates, repo, next_custom):
    for t in templates.split(' '):
        tpath = template_path(t)
        if os.path.exists(tpath):
            with open(tpath, 'r') as fp:
                lines = fp.readlines()

            if len(lines) < 2:
                print "The specified template is not valid"
                return

            output = str(lines[0]).strip(' #\n')
            if not os.path.exists(os.path.dirname(output)):
                print "The specified template output \"" + output + "\"" +\
                      "doesn't exists."

            print "Processing template \"" + t + "\" for " + output + "..."

            lines = lines[1:]

            xformed = Template("".join(lines))
            keywords = {
                'CURRENT_VERSION': build_version_string(repo, next_custom),
                'BUILD_ID': repo['build-id'],
                'FULL_BUILD_ID': repo['full-build-id'],
                'MAJOR': repo['maj'],
                'MINOR': repo['min'],
                'PATCH': repo['patch'],
                'COMMIT_COUNT': repo['count']
            }

            res = xformed.substitute(keywords)
            try:
                fp = open(output, 'w')
                fp.write(res)
                fp.close()
            except IOError:
                print "Couldn't write file \"" + output + "\""

            stat = os.stat(output)
            print "Done, " + str(stat.st_size) + " bytes written"
        else:
            print "Couldn't find the specified \"" + t + "\" template"


def load_next_store(store_file):
    data = dict()

    try:
        fp = open(store_file, 'r')
        data = pickle.load(fp)
        fp.close()
    except IOError:
        pass

    return data


def save_next_store(store_file, data):
    try:
        fp = open(store_file, 'w')
        pickle.dump(data, fp)
        fp.close()
    except IOError:
        print "Couldn't update NEXT storage (" + store_file + ")"


def main():
    check_gitdir()
    if len(sys.argv) < 2:
        sys.argv.insert(1, 'info')
    args = parse_args()
    return args.func(args)


def parse_args():
    parser = argparse.ArgumentParser()
    sp = parser.add_subparsers(title='Valid commands')

    add_command(sp, 'init', "Create gitver's configuration directory", cmd_init)

    add_command(sp, 'info', "Print version information for this repository",
                cmd_info)

    add_command(sp, 'list-templates', "Enumerates available templates",
                cmd_list_templates)

    add_command(sp, 'list-next', "Enumerates NEXT custom strings",
                cmd_list_next)

    p = add_command(sp, 'update', "Perform simple keyword substitution on the "
                                  "specified template file(s) and place it to "
                                  "the path described by the first line in the "
                                  "template.", cmd_build_template)
    p.add_argument('templates', default='', type=str)

    p = add_command(sp, 'next', "Sets the NEXT version numbers for the "
                                "currently reachable last tag. This will "
                                "suppress the usage of the \"-" + next_suffix +
                                "\" suffix, enable use of the custom \"-" +
                                next_custom_suffix +
                                "\" suffix and will use the supplied version "
                                "numbers instead.", cmd_next)
    p.add_argument('next_version_numbers', default='', type=str)

    p = add_command(sp, 'clean', "Resets the NEXT custom string for the "
                                 "currently active tag, or the specified tag, "
                                 "to a clean state. Usage of the \"-" +
                                 next_suffix + "\" suffix is restored.",
                    cmd_clean)
    p.add_argument('tag', nargs='?', type=str, default='')

    add_command(sp, 'cleanall', "Resets all the NEXT custom strings for this"
                                "repository. Usage of the \"-" + next_suffix +
                                "\" suffix is restored.", cmd_cleanall)
    return parser.parse_args()


def add_command(parent, name, desc, func):
    p = parent.add_parser(name, help=desc)
    p.set_defaults(func=func)
    return p


def cmd_init(args):
    if not os.path.exists(cfgdir):
        os.makedirs(cfgdir)
        print "Created " + cfgdir

    if not os.path.exists(tpldir):
        os.makedirs(tpldir)
        print "Created " + tpldir
        sys.exit(1)

    print "Done."


def cmd_list_templates(args):
    check_cfgdir()

    tpls = [f for f in os.listdir(tpldir) if os.path.isfile(template_path(f))]
    if len(tpls) > 0:
        print "Available templates:"
        for t in tpls:
            print "    " + t
    else:
        print "No templates available in " + tpldir


def cmd_info(args):
    check_cfgdir()
    next_store = load_next_store(next_store_file)
    repo_info = get_repo_info()
    last_tag = repo_info['last-tag']
    has_next_custom = last_tag in next_store.keys()
    next_custom = next_store[last_tag] if has_next_custom else None

    print "Current tag: " + last_tag
    if has_next_custom:
        print "NEXT version string: v" + next_custom
        print "Current version: v" + build_version_string(repo_info, next_custom)
    else:
        print "No NEXT version string found"
        print "Current version: v" + build_version_string(repo_info)


def cmd_build_template(args):
    check_cfgdir()
    next_store = load_next_store(next_store_file)
    repo_info = get_repo_info()
    last_tag = repo_info['last-tag']
    has_next_custom = last_tag in next_store.keys()
    next_custom = next_store[last_tag] if has_next_custom else None

    parse_templates(args.templates, repo_info, next_custom)


def cmd_next(args):
    check_cfgdir()
    next_store = load_next_store(next_store_file)
    repo_info = get_repo_info()

    last_tag = repo_info['last-tag']

    vn = args.next_version_numbers
    try:
        m = re.match(custom_version_matcher, vn).groups()
        if len(m) != 3:
            raise AttributeError
    except AttributeError:
        print "Please specify valid version numbers.\nThe expected " \
              "format is <MAJ>.<MIN>.<PATCH>, e.g. v0.0.1 or 0.0.1"
        sys.exit(1)

    custom = "%d.%d.%d" % (int(m[0]), int(m[1]), int(m[2]))
    next_store[last_tag] = custom
    save_next_store(next_store_file, next_store)
    print "Set NEXT version string to " + custom


def cmd_clean(args):
    check_cfgdir()
    next_store = load_next_store(next_store_file)
    if len(args.tag) > 0:
        tag = args.tag
    else:
        repo_info = get_repo_info()
        tag = repo_info['last-tag']

    has_custom = tag in next_store.keys()
    next_custom = next_store[tag] if has_custom else None

    if has_custom:
        del next_store[tag]
        save_next_store(next_store_file, next_store)
        print "Cleaned up custom string version \"" + next_custom + \
              "\" for tag \"" + tag + "\""
    else:
        print "No custom string version found for tag \"" + tag + "\""


def cmd_cleanall(args):
    check_cfgdir()
    if os.path.exists(next_store_file):
        os.unlink(next_store_file)
        print "Custom strings removed."
    else:
        print "No NEXT custom strings found."


def cmd_list_next(args):
    check_cfgdir()
    next_store = load_next_store(next_store_file)
    if len(next_store) > 0:
        print "Currently set NEXT custom strings:"
        for tag, vstring in next_store.items():
            print "    %s => %s" % (tag, vstring)
    else:
        print "No NEXT custom strings set."

if __name__ == "__main__":
    main()
