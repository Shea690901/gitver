#!/usr/bin/env python2

import os
import re
import sys
import argparse
import sh
from sh import ErrorReturnCode
from string import Template

this_script = os.path.basename(__file__)
cfgdir = ".gitver/"
gitdir = ".git/"
tpldir = os.path.join(cfgdir, 'templates')

next_suffix = "NEXT"
version_matcher = r"v{0,1}(\d+)\.(\d+)\.(\d+)-(\d+)-g([a-fA-F0-9]+)"

parser = argparse.ArgumentParser(description="Manages git version strings")

parser.add_argument('--init',
                    dest='initialize_gitver',
                    default=False,
                    action="store_true",
                    help="Perform the first initialization of gitver")

parser.add_argument('--update',
                    dest='templates',
                    default='',
                    type=str,
                    help="Perform simple keyword substitution on the specified "
                         "template file(s) and place it to the path described "
                         "by the first line in the template.")
parser.add_argument('--list-templates',
                    dest='list_templates',
                    action='store_true',
                    default=False,
                    help="Enumerates available templates")

options = parser.parse_args()


def check_gitdir():
    # check this is a git repo
    if not os.path.exists(gitdir):
        print "Please run this tool from within the root directory of your " \
              "project, where the .git directory resides."
        sys.exit(1)


def check_cfgdir():
    # check config directory exists
    if not os.path.exists(cfgdir):
        print "Please run \"" + this_script + " --init\" first."
        sys.exit(1)


def get_repo_info():
    # retrieve repository information
    try:
        tagver = sh.git('describe', '--long', '--match=v*').stdout.replace(
            '\n', '')
    except ErrorReturnCode:
        print "Error, this repository is required to define tags in the " \
              "format vX.Y.Z"
        sys.exit(1)

    try:
        vm = re.match(version_matcher, tagver)
        vm = vm.groups()
    except (ErrorReturnCode, AttributeError):
        print "It looks like the tag format isn't vX.Y.Z, please check your " \
              "tags (" + tagver + ")"
        sys.exit(1)

    try:
        full_build_id = sh.git('rev-parse', 'HEAD').stdout.replace('\n', '')
    except ErrorReturnCode:
        print "Couldn't retrieve build id information"
        sys.exit(1)

    if len(vm) < 5:
        print "There isn't enough version information"
        print vm
        sys.exit(1)

    # build version string
    vmaj = int(vm[0])
    vmin = int(vm[1])
    vpatch = int(vm[2])
    vcount = int(vm[3])
    build_id = full_build_id[:8]

    return {'maj': vmaj, 'min': vmin, 'patch': vpatch, 'count': vcount,
            'build-id': build_id, 'full-build-id': full_build_id}


def build_version(repo):
    version = "%d.%d.%d" % (repo['maj'], repo['min'], repo['patch'])
    if repo['count'] > 0:
        version += "-" + next_suffix + "-" + str(repo['count'])
    version += "/" + repo['build-id']
    return version


def gitver_init():
    os.makedirs(cfgdir)
    os.makedirs(tpldir)
    if not os.path.exists(cfgdir):
        print "Couldn't create configuration directory " + cfgdir
        sys.exit(1)
    else:
        print "Created " + cfgdir

    if not os.path.exists(tpldir):
        print "Couldn't create template directory " + tpldir
        sys.exit(1)
    else:
        print "Created " + tpldir

    print "Done."


def template_path(name):
    return os.path.join(tpldir, name)


def list_templates():
    tpls = [f for f in os.listdir(tpldir) if os.path.isfile(template_path(f))]
    if len(tpls) > 0:
        print "Available templates:"
        for t in tpls:
            print "    " + t
    else:
        print "No templates available in " + tpldir


def stringify(d):
    ret = {}
    for k, v in d.items():
        ret[k] = v if type(v) == str else str(v)
    return ret


def parse_templates(templates, repo):
    for t in templates.split(' '):
        tpath = template_path(t)
        if os.path.exists(tpath):
            with open(tpath, 'r') as fp:
                lines = fp.readlines()

            if len(lines) < 2:
                print "The specified template is not valid"
                return

            output = str(lines[0]).strip(' #\n')
            if not os.path.exists(os.path.dirname(output)):
                print "The specified template output \"" + output + "\"" +\
                      "doesn't exists."

            print "Processing template \"" + t + "\" for " + output + "..."

            lines = lines[1:]

            xformed = Template("".join(lines))
            keywords = {
                'CURRENT_VERSION': build_version(repo),
                'BUILD_ID': repo['build-id'],
                'FULL_BUILD_ID': repo['full-build-id'],
                'MAJOR': repo['maj'],
                'MINOR': repo['min'],
                'PATCH': repo['patch'],
                'COMMIT_COUNT': repo['count']
            }

            res = xformed.substitute(keywords)
            try:
                fp = open(output, 'w')
                fp.write(res)
                fp.close()
            except IOError:
                print "Couldn't write file \"" + output + "\""

            stat = os.stat(output)
            print "Done, " + str(stat.st_size) + " bytes written"
        else:
            print "Couldn't find the specified \"" + t + "\" template"


if __name__ == "__main__":
    check_gitdir()

    # handle options
    if options.initialize_gitver:
        gitver_init()

    check_cfgdir()

    repo_info = get_repo_info()
    if options.list_templates:
        list_templates()
    elif len(options.templates) > 0:
        parse_templates(options.templates, repo_info)
    else:
        # default
        print "Current version: v" + build_version(repo_info)
