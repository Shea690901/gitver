#!/usr/bin/env python2

"""
git version strings management for humans
2014 Manuel Bua
"""
import os
import re
import sys
import argparse
import pickle
from string import Template
from os.path import dirname, realpath, abspath, basename
from git import get_repo_info
from termcolors import *
from storage import KVStore

this_script = basename(__file__)

# try import version information
try:
    from version import gitver_version, gitver_buildid
except ImportError:
    gitver_version = 'n/a'
    gitver_buildid = 'n/a'


# per-repo configuration
cfgdirname = ".gitver"
cfgdir = cfgdirname + "/"
gitdir = ".git/"
tpldir = os.path.join(cfgdir, 'templates')


# file where to store NEXT strings <=> TAG user-defined mappings
next_store_file = os.path.join(cfgdir, ".next_store")


# print os.listdir(os.path.expanduser('~'))
next_suffix = "NEXT"
next_custom_suffix = "SNAPSHOT"


# defines the command decorator to require various actions
class requires(object):
    def __init__(self, func):
        self.func = func

    def __call__(self, f):
        self.func()

        def wrapped_f(*args):
            f(*args)

        return wrapped_f


def check_gitdir():
    # check this is a git repo
    if not os.path.exists(gitdir):
        print err("Please run this tool from within the root directory of your "
                  "project, where the .git directory resides.")
        sys.exit(1)


def check_config():
    # check config directory exists
    if not os.path.exists(cfgdir):
        print "Please run " + bold(this_script + " init") + " first."
        sys.exit(1)

    # check .gitignore for .gitver inclusion
    try:
        if cfgdirname in open('.gitignore').read():
            return

        print warn("Warning: it's highly advised to EXCLUDE the gitver "
                   "configuration from the repository!")
        print "Please include the following line in your .gitignore file:"
        print "    " + cfgdirname
        sys.exit(1)
    except IOError:
        print err("Error reading your .gitignore file, please create one")
        sys.exit(1)


def build_version_string(repo, next_custom=None):
    in_next = repo['count'] > 0
    if in_next and not next_custom is None and len(next_custom) > 0:
        version = next_custom
        if len(next_custom_suffix) > 0:
            version += "-" + next_custom_suffix
    else:
        version = "%d.%d.%d" % (repo['maj'], repo['min'], repo['patch'])
        if in_next:
            version += "-" + next_suffix

    if in_next:
        version += "-" + str(repo['count'])

    version += "/" + repo['build-id']

    return version


def template_path(name):
    return os.path.join(tpldir, name)


def parse_templates(templates, repo, next_custom):
    for t in templates.split(' '):
        tpath = template_path(t)
        if os.path.exists(tpath):
            with open(tpath, 'r') as fp:
                lines = fp.readlines()

            if len(lines) < 2:
                print err("The specified template " + bold(t) + " is not valid")
                return

            output = str(lines[0]).strip(' #\n')
            if not os.path.exists(os.path.dirname(output)):
                print err("The specified template output \"" + bold(output) +
                          "\"" + "doesn't exists.")

            print "Processing template \"" + bold(t) + "\" for " + output + \
                  "..."

            lines = lines[1:]

            xformed = Template("".join(lines))
            keywords = {
                'CURRENT_VERSION': build_version_string(repo, next_custom),
                'BUILD_ID': repo['build-id'],
                'FULL_BUILD_ID': repo['full-build-id'],
                'MAJOR': repo['maj'],
                'MINOR': repo['min'],
                'PATCH': repo['patch'],
                'COMMIT_COUNT': repo['count']
            }

            res = xformed.substitute(keywords)
            try:
                fp = open(output, 'w')
                fp.write(res)
                fp.close()
            except IOError:
                print err("Couldn't write file \"" + bold(output) + "\"")

            stat = os.stat(output)
            print "Done, " + str(stat.st_size) + " bytes written."
        else:
            print err("Couldn't find the specified \"" + bold(t) + "\" template")


@requires(check_gitdir)
def main():
    # inject the default action "info" if none specified
    if len(sys.argv) < 2:
        sys.argv.insert(1, 'info')
    args = parse_args()

    return args.func(args)


def parse_args():
    parser = argparse.ArgumentParser()
    sp = parser.add_subparsers(title='Valid commands')

    add_command(sp, 'version', "Show gitver version", cmd_version)
    add_command(sp, 'init', "Create gitver's configuration directory", cmd_init)

    add_command(sp, 'info', "Print version information for this repository",
                cmd_info)

    add_command(sp, 'list-templates', "Enumerates available templates",
                cmd_list_templates)

    add_command(sp, 'list-next', "Enumerates NEXT custom strings",
                cmd_list_next)

    p = add_command(sp, 'update', "Perform simple keyword substitution on the "
                                  "specified template file(s) and place it to "
                                  "the path described by the first line in the "
                                  "template.", cmd_build_template)
    p.add_argument('templates', default='', type=str)

    p = add_command(sp, 'next', "Sets the NEXT version numbers for the "
                                "currently reachable last tag. This will "
                                "suppress the usage of the \"-" + next_suffix +
                                "\" suffix, enable use of the custom \"-" +
                                next_custom_suffix +
                                "\" suffix and will use the supplied version "
                                "numbers instead.", cmd_next)
    p.add_argument('next_version_numbers', default='', type=str)

    p = add_command(sp, 'clean', "Resets the NEXT custom string for the "
                                 "currently active tag, or the specified tag, "
                                 "to a clean state. Usage of the \"-" +
                                 next_suffix + "\" suffix is restored.",
                    cmd_clean)
    p.add_argument('tag', nargs='?', type=str, default='')

    add_command(sp, 'cleanall', "Resets all the NEXT custom strings for this"
                                "repository. Usage of the \"-" + next_suffix +
                                "\" suffix is restored.", cmd_cleanall)
    return parser.parse_args()


def add_command(parent, name, desc, func):
    p = parent.add_parser(name, help=desc)
    p.set_defaults(func=func)
    return p


def cmd_version(args):
    print "This is gitver " + bold(gitver_version)
    print "Full build ID is " + bold(gitver_buildid)


def cmd_init(args):
    if not os.path.exists(cfgdir):
        os.makedirs(cfgdir)
        print "Created " + cfgdir

    if not os.path.exists(tpldir):
        os.makedirs(tpldir)
        print "Created " + tpldir
        sys.exit(1)

    print "Done."


@requires(check_config)
def cmd_info(args):
    next_store = KVStore(next_store_file)
    repo_info = get_repo_info()
    last_tag = repo_info['last-tag']

    has_next_custom = next_store.has(last_tag)
    next_custom = next_store.get(last_tag) if has_next_custom else None

    if has_next_custom:
        nvn = color_next(next_custom)
    else:
        nvn = "none defined, using " + color_next("-" + next_suffix) + " suffix"

    print "Latest tag: " + color_tag(last_tag)
    print "NEXT: " + nvn
    print "Current version: " + \
          color_version("v" + build_version_string(repo_info, next_custom))


@requires(check_config)
def cmd_list_templates(args):
    tpls = [f for f in os.listdir(tpldir) if os.path.isfile(template_path(f))]
    if len(tpls) > 0:
        print "Available templates:"
        for t in tpls:
            print "    " + bold(t) + " (" + template_path(t) + ")"
    else:
        print "No templates available in " + tpldir


@requires(check_config)
def cmd_build_template(args):
    next_store = KVStore(next_store_file)
    repo_info = get_repo_info()
    last_tag = repo_info['last-tag']
    has_next_custom = next_store.has(last_tag)
    next_custom = next_store.get(last_tag) if has_next_custom else None

    parse_templates(args.templates, repo_info, next_custom)


@requires(check_config)
def cmd_next(args):
    next_store = KVStore(next_store_file)
    repo_info = get_repo_info()

    last_tag = repo_info['last-tag']

    vn = args.next_version_numbers
    try:
        m = re.match(r"v{0,1}(\d+)\.(\d+)\.(\d+)$", vn).groups()
        if len(m) != 3:
            raise AttributeError
    except AttributeError:
        print "Please specify valid version numbers.\nThe expected " \
              "format is <MAJ>.<MIN>.<PATCH>, e.g. v0.0.1 or 0.0.1"
        sys.exit(1)

    custom = "%d.%d.%d" % (int(m[0]), int(m[1]), int(m[2]))
    next_store.set(last_tag, custom).save()
    print "Set NEXT version string to " + custom


@requires(check_config)
def cmd_clean(args):
    next_store = KVStore(next_store_file)
    if len(args.tag) > 0:
        tag = args.tag
    else:
        repo_info = get_repo_info()
        tag = repo_info['last-tag']

    has_custom = next_store.has(tag)
    next_custom = next_store.get(tag) if has_custom else None

    if has_custom:
        next_store.rm(tag).save()
        print "Cleaned up custom string version \"" + next_custom + \
              "\" for tag \"" + tag + "\""
    else:
        print "No custom string version found for tag \"" + tag + "\""


@requires(check_config)
def cmd_cleanall(args):
    if os.path.exists(next_store_file):
        os.unlink(next_store_file)
        print "Custom strings removed."
    else:
        print "No NEXT custom strings found."


@requires(check_config)
def cmd_list_next(args):
    next_store = KVStore(next_store_file)
    if not next_store.empty():
        print "Currently set NEXT custom strings:"
        for tag, vstring in next_store.items():
            print "    %s => %s" % (tag, vstring)
    else:
        print "No NEXT custom strings set."


if __name__ == "__main__":
    sys.exit(main())
