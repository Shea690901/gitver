#!/usr/bin/env python2

import os
import re
import sys
import argparse
import sh
import pickle
from sh import ErrorReturnCode
from string import Template

this_script = os.path.basename(__file__)
cfgdir = ".gitver/"
gitdir = ".git/"
tpldir = os.path.join(cfgdir, 'templates')

# file where to store NEXT user-defined version strings for the specified
# TAG key
next_store_file = os.path.join(cfgdir, ".next_store")

next_suffix = "NEXT"
next_custom_suffix = "SNAPSHOT"
version_matcher = r"v{0,1}(\d+)\.(\d+)\.(\d+)-(\d+)-g([a-fA-F0-9]+)"
custom_version_matcher = r"v{0,1}(\d+)\.(\d+)\.(\d+)$"

parser = argparse.ArgumentParser(description="Manages git version strings")

parser.add_argument('--init',
                    dest='initialize_gitver',
                    default=False,
                    action="store_true",
                    help="Perform the first initialization of gitver")

parser.add_argument('--update',
                    dest='templates',
                    default='',
                    type=str,
                    help="Perform simple keyword substitution on the specified "
                         "template file(s) and place it to the path described "
                         "by the first line in the template.")

parser.add_argument('--next',
                    dest='next_version_numbers',
                    type=str,
                    default='',
                    help="Sets the NEXT version numbers for the currently "
                         "reachable last tag. This will suppress the usage of "
                         "the \"-" + next_suffix + "\" suffix and will use the "
                                                   "supplied one instead.")

parser.add_argument('--clean',
                    dest='clean_next_version',
                    action='store_true',
                    default=False,
                    help="Reset the custom string for the currently active"
                         "tag to a clean state. Usage of the \"-" +
                         next_suffix + "\" suffix is restored.")

parser.add_argument('--list',
                    dest='list_templates',
                    action='store_true',
                    default=False,
                    help="Enumerates available templates")


def check_gitdir():
    # check this is a git repo
    if not os.path.exists(gitdir):
        print "Please run this tool from within the root directory of your " \
              "project, where the .git directory resides."
        sys.exit(1)


def check_cfgdir():
    # check config directory exists
    if not os.path.exists(cfgdir):
        print "Please run \"" + this_script + " --init\" first."
        sys.exit(1)


def get_repo_info():
    # retrieve repository information
    try:
        tagver = sh.git(
            'describe', '--long', '--match=v*').stdout.replace('\n', '')
    except ErrorReturnCode:
        print "Error, this repository is required to define tags in the " \
              "format vX.Y.Z"
        sys.exit(1)

    try:
        vm = re.match(version_matcher, tagver)
        vm = vm.groups()
    except AttributeError:
        print "It looks like the tag format isn't vX.Y.Z, please check your " \
              "tags (" + tagver + ")"
        sys.exit(1)

    # extract version string
    vmaj = int(vm[0])
    vmin = int(vm[1])
    vpatch = int(vm[2])
    vcount = int(vm[3])
    vhash = vm[4]

    try:
        full_build_id = str(
            sh.git('rev-parse', 'HEAD').stdout.replace('\n', ''))
        build_id = full_build_id[:8]
    except ErrorReturnCode:
        print "Couldn't retrieve build id information"
        sys.exit(1)

    if len(vm) < 5:
        print "There isn't enough version information"
        print vm
        sys.exit(1)

    if not full_build_id.startswith(vhash):
        print "Hash problem detected: git describe reports " + vhash + \
              ", but full id is " + full_build_id

    try:
        last_tag = sh.git('describe', '--abbrev=0').stdout.replace('\n', '')
    except ErrorReturnCode:
        print "Error, couldn't retrieve latest tag"
        sys.exit(1)

    return {'maj': vmaj, 'min': vmin, 'patch': vpatch, 'count': vcount,
            'build-id': build_id, 'full-build-id': full_build_id,
            'last-tag': last_tag}


def build_version(repo, next_custom=''):
    in_next = repo['count'] > 0
    if in_next and not next_custom is None and len(next_custom) > 0:
        version = next_custom
        if len(next_custom_suffix) > 0:
            version += "-" + next_custom_suffix
    else:
        version = "%d.%d.%d" % (repo['maj'], repo['min'], repo['patch'])
        if in_next:
            version += "-" + next_suffix

    if in_next:
        version += "-" + str(repo['count'])

    version += "/" + repo['build-id']

    return version


def gitver_init():
    os.makedirs(cfgdir)
    os.makedirs(tpldir)
    if not os.path.exists(cfgdir):
        print "Couldn't create configuration directory " + cfgdir
        sys.exit(1)
    else:
        print "Created " + cfgdir

    if not os.path.exists(tpldir):
        print "Couldn't create template directory " + tpldir
        sys.exit(1)
    else:
        print "Created " + tpldir

    print "Done."


def template_path(name):
    return os.path.join(tpldir, name)


def list_templates():
    tpls = [f for f in os.listdir(tpldir) if os.path.isfile(template_path(f))]
    if len(tpls) > 0:
        print "Available templates:"
        for t in tpls:
            print "    " + t
    else:
        print "No templates available in " + tpldir


def stringify(d):
    ret = {}
    for k, v in d.items():
        ret[k] = v if type(v) == str else str(v)
    return ret


def parse_templates(templates, repo, next_custom):
    for t in templates.split(' '):
        tpath = template_path(t)
        if os.path.exists(tpath):
            with open(tpath, 'r') as fp:
                lines = fp.readlines()

            if len(lines) < 2:
                print "The specified template is not valid"
                return

            output = str(lines[0]).strip(' #\n')
            if not os.path.exists(os.path.dirname(output)):
                print "The specified template output \"" + output + "\"" +\
                      "doesn't exists."

            print "Processing template \"" + t + "\" for " + output + "..."

            lines = lines[1:]

            xformed = Template("".join(lines))
            keywords = {
                'CURRENT_VERSION': build_version(repo, next_custom),
                'BUILD_ID': repo['build-id'],
                'FULL_BUILD_ID': repo['full-build-id'],
                'MAJOR': repo['maj'],
                'MINOR': repo['min'],
                'PATCH': repo['patch'],
                'COMMIT_COUNT': repo['count']
            }

            res = xformed.substitute(keywords)
            try:
                fp = open(output, 'w')
                fp.write(res)
                fp.close()
            except IOError:
                print "Couldn't write file \"" + output + "\""

            stat = os.stat(output)
            print "Done, " + str(stat.st_size) + " bytes written"
        else:
            print "Couldn't find the specified \"" + t + "\" template"


def load_next_store(store_file):
    data = dict()

    try:
        fp = open(store_file, 'r')
        data = pickle.load(fp)
        fp.close()
    except IOError:
        pass

    return data


def save_next_store(store_file, data):
    try:
        fp = open(store_file, 'w')
        pickle.dump(data, fp)
        fp.close()
    except IOError:
        print "Couldn't update NEXT storage (" + store_file + ")"


def main():
    check_gitdir()

    # handle options
    options = parser.parse_args()
    if options.initialize_gitver:
        gitver_init()
        sys.exit()

    # setup
    check_cfgdir()
    next_store = load_next_store(next_store_file)
    repo_info = get_repo_info()
    # print repo_info

    # global data
    last_tag = repo_info['last-tag']
    has_next_custom = last_tag in next_store.keys()
    next_custom = next_store[last_tag] if has_next_custom else None

    # list available templates
    if options.list_templates:
        list_templates()
        sys.exit()

    # clean NEXT custom version string for this tag
    if options.clean_next_version:
        if has_next_custom:
            del next_store[last_tag]
            save_next_store(next_store_file, next_store)
            print "Cleaned up custom string version \"" + next_custom + \
                  "\" for tag \"" + last_tag + "\""
        else:
            print "No custom string version to clean for tag \"" + last_tag + \
                  "\""
        sys.exit()

    # set NEXT custom version string for this tag
    if len(options.next_version_numbers) > 0:
        vn = options.next_version_numbers
        try:
            m = re.match(custom_version_matcher, vn).groups()
            if len(m) != 3:
                raise AttributeError
        except AttributeError:
            print "Please specify valid version numbers.\nThe expected " \
                  "format is <MAJ>.<MIN>.<PATCH>, e.g. v0.0.1 or 0.0.1"
            sys.exit(1)

        custom = "%d.%d.%d" % (int(m[0]), int(m[1]), int(m[2]))
        next_store[last_tag] = custom
        save_next_store(next_store_file, next_store)
        print "Set NEXT version string to " + custom
        sys.exit()

    # update template(s)
    if len(options.templates) > 0:
        parse_templates(options.templates, repo_info, next_custom)
        sys.exit()

    # default
    print "Current tag: " + last_tag
    if has_next_custom:
        print "NEXT version string: v" + next_custom
        print "Current version: v" + build_version(repo_info, next_custom)
    else:
        print "No NEXT version string found"
        print "Current version: v" + build_version(repo_info)


if __name__ == "__main__":
    main()
